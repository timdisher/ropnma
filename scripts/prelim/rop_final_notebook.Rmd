---
title: "ROP NMA Final Analysis"
author: "Timothy Disher"
output: html_notebook
---
#Purpose of the Notebook
The purpose of this document is to house all the necesarry code for analysis including a narrative of interpretations and explanation of any reasons for deviating from protocol. The final script of the analysis is exported as a single r script which will be used for preperation of the final manuscript. Please consider **this document** as the most up to date analysis file. Replication of the final manuscript should take the following form:    
  
1. Execute all script in this notebook.  
2. Knit the manuscript markdown document.  
  
Please note that this analysis was undertaken beginning July 4th, 2017 in the summer of my first year in the PhD program at Dalhousie University. As such this served the dual purpose of providing and opportunity to learn approaches to functional programming.
  
#Data Cleaning
The purpose of this section is to explore the merged data file, identify any potential errors and create a final clean set for analysis.  
```{r}
library(tidyverse)
library(readxl)
library(forcats)
library(broom)
library(stargazer)
library(netmeta)
```


```{r}
data_arm = read_excel(path = "./data/final_analysis_ROP_data_good_jul4.xlsx", sheet = 1,
                      col_types = )
data_study = read_excel(path = "./data/final_analysis_ROP_data_good_jul4.xlsx", sheet = 2)
head(data_arm)
tail(data_arm)
head(data_study)
tail(data_study)

summary(data_arm)
summary(data_study)
```

Everything appears to have been imported correctly. Some changes that will make things a little easier may be to make treatment, trt.group, outcome, actual.timepoint, and timepoint.group into factors.

```{r}
data_arm[,2:7] = map(data_arm[,2:7],as_factor) ## runs along columns 2:7 and applies as_factor
data_study[,-c(1,3,9,26:28)] = map(data_study[,-c(1,3,9,26:28)],as_factor)

summary(data_arm,maxsum = 50) ### identifying slight mispellings
summary(data_study,maxum= 50)

```
#Sweet.rep to sweet, and fix trt groups
```{r}
data_arm %>% filter(trt.group == "sweet.rep") 
data_arm = data_arm %>% mutate(trt.group = replace(trt.group, trt.group == "drops.nns","drops.phys"),
                               treatment = replace(treatment, treatment == "sweet.rep","sweet"))
data_arm = data_arm %>% mutate(trt.group = replace(trt.group, trt.group == "sweet.rep","sweet"))
                               
```



#Outcome summaries
The first piece of information that will be required for reporting is a simple summary of the trials, their size

##All Studies - high level for inclusion after prisma
```{r}
data_summary = data_study %>% map(summary)

##--Full summary table--##


summary_table = tibble(Characteristic = c(
  "Number of Studies",
  "Number of Publications",
  "Journal Publications",
  "Posters",
  "Parallel RCT",
  "Crossover RCT",
  "Number of Treatments",
  "Number of Treatment Groups",
  "Smallest Study",
  "Largest Study",
  "Median Study Size"),
  Number =
    c(length(data_summary$study) - sum(data_study$`dup code`),
      length(data_summary$study),
      sum(data_summary$`pub type`[["journal"]]),
      sum(data_summary$`pub type`[["poster"]]),
  sum(data_summary$design[["Parallel"]]),
  sum(data_summary$design[["Crossover"]]),
  nlevels(data_arm$treatment),
  nlevels(data_arm$trt.group),
  min(data_study$n),
  max(data_study$n),
  median(data_study$n))
)
data_arm
stargazer(summary_table, summary = FALSE, out = "figs/overall summary.html",rownames = FALSE)


##Lumping and splitting
lump = data_arm %>% select(treatment, trt.group) %>% distinct()
lump[["trt.group"]] = fct_relevel(lump[["trt.group"]],"drops")
lump %>% arrange(trt.group) %>% mutate(treatment = as.character(treatment),
                                       trt.group = as.character(trt.group)) %>%rename("Treatment" = treatment,
                                       "Treatment Group "= trt.group) %>%
  stargazer(summary = FALSE, out = "figs/lump_split.html", rownames = FALSE)

```

##Primary outcome: Validated Pain Assessment Tool - Reactivity
```{r}

#-----------------------------------------------------------------------------------------------------------------------------

#- Pain Assessment Reactivity -#

#-----------------------------------------------------------------------------------------------------------------------------
source("netmetaxl_tables_function.R")

pa_reac = data_arm %>% filter(outcome == "PIPP" | outcome == "NIPS", timepoint.group == "reactivity") 

### converts data to correct format to allow for assessment of connectivity
pa_reac_contrast = pairwise(data = pa_reac,treat = trt.group, n= sample.size, mean = mean,sd = std.dev,studlab = study) 

#- Assess whether network is connected -#
pa_reac_netconnect = netconnection(treat1,treat2,data = pa_reac_contrast)
pa_reac_int = netmeta(TE,seTE,treat1,treat2,studlab,data = pa_reac_contrast, sm = "MD") ###required to drawn netgraph


### Generate characteristic tables
netmeta_xl_chars(pa_reac,"pa_reac",ref = "drops",treat = "trt.group",location = "./figs/primary outcome/pain scales reactivity")
momlinc_netgraph(pa_reac_int,pa_reac_int_char,"pa_reac",2,location = "./figs/primary outcome/pain scales reactivity")


```

###Assessing missing means - Symmetry in medians?
```{r}
pa_reac %>% filter(mean == 888) %>% mutate(mean_imp = )

pa_reac = pa_reac %>% mutate(mean_imp = ifelse(mean == 888, median,mean)) # creates a new variable where missing means are imputed from medians

pa_reac = data_study %>% select(study,speculum,scleral.dep,`Containment vs Swaddle`) %>% right_join(pa_reac, by = "study") # bring study level data over

pa_reac %>% select(median, range.low, range.high,iqr.low,iqr.high) %>% filter(median < 999, range.low < 999) %>% mutate(low_dist = median - range.low,
                  high_dist = range.high - median)



```

###Placebo response graphs
```{r}

names = c("speculum","scleral.dep","`Containment vs Swaddle`")

pa_reac_loc = c("./figs/primary outcome/pain scales reactivity")
plac_resp_graph(data = pa_reac, ref = "drops",facet = FALSE, location = pa_reac_loc)

for(i in seq_along(names)){
  plac_resp_graph(data = pa_reac, ref = "drops",facet = TRUE, fv = names[i], location = pa_reac_loc,type = "bar")
}

#### As scatter plots
pa_reac_contrast= pairwise(data = pa_reac,treat = trt.group, n = sample.size, mean = mean_imp, sd = std.dev, studlab = study)## remakes contrast based on imputed means

plac_resp_graph(data = pa_reac_contrast, ref = "drops",filter = "treat1",facet = FALSE, location = pa_reac_loc, 
               x = "treat2", y = "mean1", type = "scat", fill = "studlab", size = "n1", outcome = "pa_recov")
```

###Table of Study Characterstics
```{r}
data_study_table = data_study
data_study_table[data_study == 888 | data_study == 999] <- NA

pa_reac_study_char = data_study_table %>% select(study,n,design,ctrl.group,trt1.group2,trt2.group,trt3.group,method,speculum,scleral.dep,avg.pma,`Containment vs Swaddle`) %>% semi_join((pa_reac %>% select(study) %>% distinct()),by = "study") %>% mutate(avg.pma = round(as.numeric(avg.pma),2))
  

pa_reac_study_char[,c(1,3:10,12)] = map(pa_reac_study_char[,c(1,3:10,12)],as.character)

stargazer(pa_reac_study_char, out = "./figs/primary outcome/pain scales reactivity/pa_reac_study_char.html",summary = FALSE, rownames = FALSE)
```


##Pain Recovery

```{r}
#-----------------------------------------------------------------------------------------------------------------------------

#- Pain Assessment Recovery -#

#-----------------------------------------------------------------------------------------------------------------------------

pa_recov = data_arm %>% filter(outcome == "PIPP", timepoint.group == "recovery")
pa_recov_contrast = pairwise(data =pa_recov,treat = trt.group, n= sample.size, mean = mean,sd = std.dev,studlab = study)

pa_recov_netconnect = netconnection(treat1,treat2,data = pa_recov_contrast)
pa_recov_int = netmeta(TE,seTE,treat1,treat2,studlab,data = pa_recov_contrast, sm = "MD") ###required to drawn netgraph

### Generate characteristic tables
pa_recov_loc = c("./figs/primary outcome/pain scales recovery")
netmeta_xl_chars(pa_recov,"pa_recov",ref = "drops",treat = "trt.group",location = pa_recov_loc)
momlinc_netgraph(pa_recov_int,pa_recov_int_char,"pa_recov",2,location = pa_recov_loc)

pa_recov_study_char = data_study_table %>% select(study,n,design,ctrl.group,trt1.group2,trt2.group,trt3.group,method,speculum,scleral.dep,avg.pma,`Containment vs Swaddle`) %>% semi_join((pa_recov %>% select(study) %>% distinct()),by = "study") %>% mutate(avg.pma = round(as.numeric(avg.pma),2))
  

pa_recov_study_char[,c(1,3:10,12)] = map(pa_recov_study_char[,c(1,3:10,12)],as.character)

stargazer(pa_recov_study_char, out = "./figs/primary outcome/pain scales recovery/pa_recov_study_char.html",summary = FALSE, rownames = FALSE)


```

###Assessing missing means - Symmetry in medians?
```{r}

pa_recov = pa_recov %>% mutate(mean_imp = ifelse(mean == 888, median,mean)) %>% filter(mean_imp != 999) # creates a new variable where missing means are imputed from medians and excludes remaining 888s

pa_recov = data_study %>% select(study,speculum,scleral.dep,`Containment vs Swaddle`) %>% right_join(pa_recov, by = "study") # bring study level data over
```

###Placebo response graphs
```{r}
names = c("speculum","scleral.dep","`Containment vs Swaddle`")


plac_resp_graph(data = pa_recov, ref = "drops",facet = FALSE, location = pa_recov_loc, outcome = "pa_recov")

for(i in seq_along(names)){
  plac_resp_graph(data = pa_recov, ref = "drops",facet = TRUE, fv = names[i], location = pa_recov_loc, outcome = "pa_recov",type = "bar")
}

#### As scatter plots
pa_recov_contrast= pairwise(data = pa_recov,treat = trt.group, n = sample.size, mean = mean_imp, sd = std.dev, studlab = study)## remakes contrast based on imputed means

plac_resp_graph(data = pa_recov_contrast, ref = "drops",filter = "treat1",facet = FALSE, location = pa_recov_loc, 
               x = "treat2", y = "mean1", type = "scat", fill = "studlab", size = "n1", outcome = "pa_recov")
```


